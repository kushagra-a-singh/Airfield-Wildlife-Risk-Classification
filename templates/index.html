<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Airfield Wildlife Risk Classification</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            background: #181a1b;
            color: #f1f1f1;
        }

        .container {
            max-width: 1200px;
            margin-top: 40px;
        }

        .main-row {
            display: flex;
            flex-wrap: wrap;
            gap: 32px;
        }

        .left-col {
            flex: 1 1 420px;
            min-width: 320px;
            max-width: 600px;
        }

        .right-col {
            flex: 1 1 340px;
            min-width: 320px;
            max-width: 540px;
        }

        .result-img,
        #videoCanvas {
            max-width: 100%;
            border-radius: 8px;
            border: 2px solid #333;
            background: #222;
        }

        .results-panel {
            background: #23272b;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .summary-card {
            background: #23272b;
            border-radius: 10px;
            padding: 18px 20px;
            margin-bottom: 18px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.10);
        }

        .badge-model {
            background: #6c63ff;
            color: #fff;
            font-size: 1em;
            border-radius: 1em;
            padding: 0.4em 1em;
            margin-right: 8px;
        }

        .risk-high {
            color: #ff4c4c;
            font-weight: bold;
        }

        .risk-moderate {
            color: #f1c40f;
            font-weight: bold;
        }

        .risk-low {
            color: #27ae60;
            font-weight: bold;
        }

        .badge-risk {
            font-size: 1em;
            padding: 0.4em 0.7em;
            border-radius: 1em;
        }

        .badge-high {
            background: #ff4c4c;
            color: #fff;
        }

        .badge-moderate {
            background: #f1c40f;
            color: #222;
        }

        .badge-low {
            background: #27ae60;
            color: #fff;
        }

        .detection-card {
            background: #23272b;
            border-radius: 8px;
            padding: 14px 18px;
            margin-bottom: 14px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.10);
        }

        .detection-card .icon {
            font-size: 1.5em;
            margin-right: 8px;
        }

        .progress-bar {
            background: #222;
            border-radius: 6px;
            height: 18px;
            margin-bottom: 8px;
            border: 1.5px solid #e67e22;
            width: 100%;
            display: block;
            position: relative;
            overflow: hidden;
        }

        .progress {
            background: linear-gradient(90deg, #ff9800 0%, #ffc107 100%);
            height: 100%;
            border-radius: 6px;
            transition: width 0.4s cubic-bezier(.4, 2, .6, 1);
            display: block;
            position: absolute;
            left: 0;
            top: 0;
        }

        .video-progress-label {
            font-size: 0.95em;
            color: #bbb;
            margin-bottom: 6px;
        }

        .chart-legend {
            font-size: 0.95em;
            margin-top: 8px;
        }

        @media (max-width: 900px) {
            .main-row {
                flex-direction: column;
                gap: 0;
            }

            .left-col,
            .right-col {
                max-width: 100%;
            }
        }

        #videoResult {
            display: none;
            flex-direction: column;
            align-items: center;
        }

        #videoCanvas {
            display: block;
            max-width: 100%;
            background: #222;
            border-radius: 8px;
            margin: 0 auto;
            border: 2px solid #333;
        }

        #imageResult {
            display: none;
        }

        #stopStreamBtn {
            display: inline-block;
            opacity: 0.6;
            pointer-events: none;
        }

        #loadingSpinner {
            display: none;
        }

        #videoProgress {
            width: 0%;
        }

        #resultsSection {
            display: none;
        }

        #resultsSection {
            transition: opacity 0.3s ease;
        }

        .results-visible {
            display: block !important;
            opacity: 1 !important;
        }

        .processing-complete #resultsSection {
            display: block !important;
        }

        #videoProgress.complete {
            background: #27ae60;
        }

        .status-message {
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
        }

        .status-success {
            background: rgba(39, 174, 96, 0.2);
            color: #27ae60;
        }

        .status-warning {
            background: rgba(241, 196, 15, 0.2);
            color: #f1c40f;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="d-flex justify-content-end mb-2" id="controlButtons">
            <button class="btn btn-danger btn-sm me-2" id="stopStreamBtn" disabled>‚èπ Stop
                Streaming</button>
            <button class="btn btn-secondary btn-sm" id="restartBtn">üîÑ Restart/Refresh</button>
        </div>
        <h2 class="mb-4 text-center">ü¶Ö Airfield Wildlife Risk Classification</h2>
        <div class="mb-4">
            <label for="modelSelect" class="form-label">Select Model</label>
            <select class="form-select mb-2" id="modelSelect">
                <option value="ensemble">Ensemble (ResNet18 + MobileNetV2)</option>
                <option value="resnet18">ResNet18</option>
                <option value="mobilenetv2">MobileNetV2</option>
            </select>
            <label for="fileUpload" class="form-label">Upload Image or Video</label>
            <input class="form-control" type="file" id="fileUpload" accept="image/*,video/*">
            <div id="uploadResult" class="mt-2"></div>
            <div id="loadingSpinner" class="mt-2"><span class="spinner-border spinner-border-sm text-warning"></span>
                Processing...</div>
        </div>
        <div class="main-row">
            <div class="left-col">
                <div id="imageResult">
                    <h5>Annotated Image</h5>
                    <img id="annotatedImg" class="result-img mb-3" src="" alt="Annotated Result">
                </div>
                <div id="videoResult">
                    <h5>Video Stream</h5>
                    <div class="video-progress-label" id="videoProgressLabel"></div>
                    <div class="progress-bar mt-1">
                        <div class="progress" id="videoProgress"></div>
                    </div>
                    <canvas id="videoCanvas" width="600" height="400"></canvas>
                </div>
            </div>
            <div class="right-col">
                <div class="results-panel" id="resultsSection">
                    <div id="sessionSummary" class="mb-3"></div>
                    <h6 class="mb-3">Detection Results</h6>
                    <div id="detectionList"></div>
                    <div id="riskSummary" class="mt-3"></div>
                    <div class="mt-4">
                        <h6>Risk Trend</h6>
                        <canvas id="riskChart" height="120"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        const modelSelect = document.getElementById('modelSelect');
        const fileUpload = document.getElementById('fileUpload');
        const imageResult = document.getElementById('imageResult');
        const videoResult = document.getElementById('videoResult');
        const uploadResult = document.getElementById('uploadResult');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const annotatedImg = document.getElementById('annotatedImg');
        const detectionList = document.getElementById('detectionList');
        const riskSummary = document.getElementById('riskSummary');
        const sessionSummaryDiv = document.getElementById('sessionSummary');
        const videoCanvas = document.getElementById('videoCanvas');
        const ctx = videoCanvas.getContext('2d');
        let riskChart, speciesChart, riskBarChart;
        let videoDuration = 0;
        let videoCurrent = 0;
        let streamEnded = false;
        let streamController = null;
        let lastFrameId = -1;
        let frameRenderThrottle = 2; 
        let lowResourceMode = false;
        let pollSessionTimeout = null;
        window.keepResultsVisible = false;
        window.finalSessionSummary = null;
        window.summaryLocked = false;
        window.pollingActive = false;
        window.speciesChart = null;
        window.riskBarChart = null;

        const resultsSection = document.getElementById('resultsSection');
        const observer = new MutationObserver(() => {
            console.log('resultsSection display changed:', resultsSection.style.display);
        });
        observer.observe(resultsSection, { attributes: true, attributeFilter: ['style'] });

        function forceResultsVisible() {
            const resultsSection = document.getElementById('resultsSection');
            let count = 0;
            const interval = setInterval(() => {
                resultsSection.style.display = 'block';
                count++;
                if (count > 10) clearInterval(interval);
            }, 500);
        }

        function findBoundary(buf, boundaryStr) {
            for (let i = 0; i < buf.length - boundaryStr.length; i++) {
                let match = true;
                for (let j = 0; j < boundaryStr.length; j++) {
                    if (buf[i + j] !== boundaryStr.charCodeAt(j)) {
                        match = false; break;
                    }
                }
                if (match) return i;
            }
            return -1;
        }

        let processingComplete = false;

        function setResultsSectionVisible(visible) {
            const resultsSection = document.getElementById('resultsSection');
            if (window.keepResultsVisible || processingComplete) {
                resultsSection.style.display = 'block';
                return;
            }
            resultsSection.style.display = visible ? 'block' : 'none';
        }

        fileUpload.addEventListener('change', function (e) {
            processingComplete = false;
            window.keepResultsVisible = false;
            window.summaryLocked = false;
            const file = e.target.files[0];
            if (!file) return;
            imageResult.style.display = 'none';
            videoResult.style.display = 'none';
            uploadResult.textContent = 'Uploading...';
            streamEnded = false;
            if (streamController) streamController.abort();
            loadingSpinner.style.display = '';
            sessionSummaryDiv.innerHTML = '';
            detectionList.innerHTML = '';
            riskSummary.innerHTML = '';
            setResultsSectionVisible(false);
            const formData = new FormData();
            formData.append('model', modelSelect.value);
            if (file.type.startsWith('video/')) {
                formData.append('video', file);
            } else {
                formData.append('image', file);
            }
            fetch('/upload', {
                method: 'POST',
                body: formData
            })
                .then(res => res.json())
                .then(data => {
                    loadingSpinner.style.display = 'none';
                    if (data.success && data.filetype === 'image') {
                        annotatedImg.src = `/data/sample_videos/${data.annotated}`;
                        showDetections(data.results);
                        showSessionSummary(data.session_summary);
                        imageResult.style.display = '';
                        videoResult.style.display = 'none';
                        uploadResult.textContent = 'Image processed.';
                        riskSummary.innerHTML = '';
                        if (riskChart) riskChart.destroy();
                        setResultsSectionVisible(true);
                    } else if (data.success && data.filetype === 'video') {
                        imageResult.style.display = 'none';
                        videoResult.style.display = 'flex';
                        uploadResult.textContent = 'Video uploaded. Streaming...';
                        startRiskChart();
                        getVideoDuration(file);
                        streamEnded = false;
                        window.pollingActive = true;
                        startVideoStream();
                        pollSessionSummary();
                        setResultsSectionVisible(true);
                    } else {
                        uploadResult.textContent = 'Upload failed: ' + (data.error || 'Unknown error');
                    }
                    
                    const stopBtn = document.getElementById('stopStreamBtn');
                    stopBtn.disabled = file.type.startsWith('video/') ? false : true;
                    stopBtn.style.opacity = file.type.startsWith('video/') ? 1 : 0.6;
                    stopBtn.style.pointerEvents = file.type.startsWith('video/') ? 'auto' : 'none';
                })
                .catch(() => {
                    loadingSpinner.style.display = 'none';
                    uploadResult.textContent = 'Upload failed.';
                });
        });

        function showSessionSummary(summary) {
            console.log('showSessionSummary called. summaryLocked:', window.summaryLocked, 'summary:', summary, 'processingComplete:', processingComplete);
            if (window.summaryLocked && !processingComplete) {
                console.log('showSessionSummary: locked, skipping render');
                return;
            }
            if (!summary || !summary.total_detections) {
                console.log('showSessionSummary: no summary or total_detections');
                sessionSummaryDiv.innerHTML = '';
                return;
            }
            
            window.finalSessionSummary = summary;
           
            let modelBadge = `<span class="badge-model"><span class="icon">üß†Model</span> ${modelLabel(modelSelect.value)}</span>`;
           
            let html = `<div class="summary-card">
                <div class="mb-2">${modelBadge}</div>
                <div class="mb-2"><b>Total Detections:</b> <span style="font-size:1.2em;">${summary.total_detections}</span></div>
                <div class="row g-2">
                    <div class="col-6"><canvas id="speciesChartCanvas" height="120"></canvas><div class="chart-legend">Species</div></div>
                    <div class="col-6"><canvas id="riskBarChartCanvas" height="120"></canvas><div class="chart-legend">Risk Levels</div></div>
                </div>
            </div>`;
            setResultsSectionVisible(true); 
            sessionSummaryDiv.innerHTML = html;

            const delay = processingComplete ? 200 : 0;

            console.log('showSessionSummary: About to create charts with delay:', delay, 'processingComplete:', processingComplete);

            setTimeout(() => {
                
                const resultsSection = document.getElementById('resultsSection');
                console.log('showSessionSummary: Results section display:', resultsSection.style.display, 'visibility:', resultsSection.style.visibility);

                let speciesLabels = Object.keys(summary.species_distribution);
                let speciesCounts = Object.values(summary.species_distribution);
                let speciesColors = ["#6c63ff", "#e67e22", "#27ae60", "#f1c40f", "#ff4c4c", "#00b894", "#fdcb6e"];
                let riskLabels = ['HIGH', 'MODERATE', 'LOW'];
                let riskCounts = [summary.risk_levels.high, summary.risk_levels.moderate, summary.risk_levels.low];
                let riskColors = ["#ff4c4c", "#f1c40f", "#27ae60"];
                
                const speciesCanvas = document.getElementById('speciesChartCanvas');
                const ctxPie = speciesCanvas ? speciesCanvas.getContext('2d') : null;
                console.log('speciesCanvas:', speciesCanvas, 'ctxPie:', ctxPie, 'speciesLabels:', speciesLabels, 'speciesCounts:', speciesCounts);
                if (window.speciesChart) {
                    window.speciesChart.destroy();
                }
                let chartAnimation = !(window.keepResultsVisible || processingComplete);
                console.log('Creating species chart with animation:', chartAnimation, 'processingComplete:', processingComplete);
                if (ctxPie) {
                    try {
                        window.speciesChart = new Chart(ctxPie, {
                            type: 'doughnut',
                            data: { labels: speciesLabels, datasets: [{ data: speciesCounts, backgroundColor: speciesColors }] },
                            options: { animation: chartAnimation, plugins: { legend: { labels: { color: '#fff' } } } }
                        });
                        console.log('Species chart created successfully');
                    } catch (error) {
                        console.error('Error creating species chart:', error);
                    }
                } else {
                    console.error('speciesCanvas or ctxPie is null');
                }
                
                const riskCanvas = document.getElementById('riskBarChartCanvas');
                const ctxBar = riskCanvas ? riskCanvas.getContext('2d') : null;
                console.log('riskCanvas:', riskCanvas, 'ctxBar:', ctxBar, 'riskLabels:', riskLabels, 'riskCounts:', riskCounts);
                if (window.riskBarChart) {
                    window.riskBarChart.destroy();
                }
                console.log('Creating risk bar chart with animation:', chartAnimation);
                if (ctxBar) {
                    try {
                        window.riskBarChart = new Chart(ctxBar, {
                            type: 'bar',
                            data: { labels: riskLabels, datasets: [{ data: riskCounts, backgroundColor: riskColors }] },
                            options: { animation: chartAnimation, indexAxis: 'y', plugins: { legend: { display: false } }, scales: { x: { ticks: { color: '#fff' } }, y: { ticks: { color: '#fff' } } } }
                        });
                        console.log('Risk bar chart created successfully');
                       
                        if (!chartAnimation) {
                            window.riskBarChart.update({ animation: false });
                        }
                    } catch (error) {
                        console.error('Error creating risk bar chart:', error);
                    }
                } else {
                    console.error('riskCanvas or ctxBar is null');
                }
            }, delay);
        }

        function createChartCanvas(id, parent) {
            let c = document.createElement('canvas');
            c.id = id;
            c.height = 120;
            parent.appendChild(c);
            return c.getContext('2d');
        }

        function modelLabel(model) {
            if (model === 'ensemble') return 'Ensemble (ResNet18 + MobileNetV2)';
            if (model === 'resnet18') return 'ResNet18';
            if (model === 'mobilenetv2') return 'MobileNetV2';
            return model;
        }

        function pollSessionSummary() {
            console.log('pollSessionSummary called. pollingActive:', window.pollingActive);
            if (!window.pollingActive) {
                if (pollSessionTimeout) {
                    clearTimeout(pollSessionTimeout);
                    pollSessionTimeout = null;
                }
                return;
            }
            fetch('/api/session_summary').then(res => res.json()).then(summary => {
               
                if (window.keepResultsVisible || processingComplete) {
                    showSessionSummary(summary);
                    setResultsSectionVisible(true);
                }
                if (window.pollingActive) {
                    pollSessionTimeout = setTimeout(pollSessionSummary, 2000);
                } else {
                    if (pollSessionTimeout) {
                        clearTimeout(pollSessionTimeout);
                        pollSessionTimeout = null;
                    }
                }
            });
        }

        function showDetections(results) {
            detectionList.innerHTML = '';
            riskSummary.innerHTML = '';
            if (!results || results.length === 0) {
                detectionList.innerHTML = '<div class="text-muted">No birds detected.</div>';
                return;
            }
            let high = 0, moderate = 0, low = 0;
            results.forEach(det => {
                const riskClass = det.risk_level === 'high' ? 'badge-high' : (det.risk_level === 'moderate' ? 'badge-moderate' : 'badge-low');
                const riskIcon = det.risk_level === 'high' ? 'üî¥' : (det.risk_level === 'moderate' ? 'üü°' : 'üü¢');
                if (det.risk_level === 'high') high++;
                else if (det.risk_level === 'moderate') moderate++;
                else low++;
                detectionList.innerHTML += `
                <div class="detection-card">
                    <div><span class="icon">ü¶Ö</span><b>Species:</b> ${det.species || 'Unknown'}</div>
                    <div><span class="icon">üìè</span><b>Size:</b> ${det.size_category}</div>
                    <div><span class="icon">‚ö°</span><b>Confidence:</b> ${(det.confidence * 100).toFixed(1)}%</div>
                    <div><span class="icon">ü¶ã</span><b>Behavior:</b> ${det.behavior || 'Unknown'}</div>
                    <div><span class="icon">üß†</span><b>Model:</b> ${modelLabel(det.model)}</div>
                    <div><span class="icon">${riskIcon}</span><b>Risk:</b> <span class="badge-risk ${riskClass}">${det.risk_level.toUpperCase()}</span> (Score: ${det.risk_score.toFixed(2)})</div>
                </div>`;
            });
            
            let summary = '';
            if (high > 0) summary += `<span class="badge badge-high me-2">${high} HIGH</span>`;
            if (moderate > 0) summary += `<span class="badge badge-moderate me-2">${moderate} MODERATE</span>`;
            if (low > 0) summary += `<span class="badge badge-low me-2">${low} LOW</span>`;
            if (summary) riskSummary.innerHTML = `<b>Risk Assessment:</b> ${summary}`;
        }

        function startRiskChart() {
            if (riskChart) riskChart.destroy();
            const ctx = document.getElementById('riskChart').getContext('2d');
            riskChart = new Chart(ctx, {
                type: 'line',
                data: { labels: [], datasets: [{ label: 'Risk Score', data: [], borderColor: '#e67e22', backgroundColor: getGradient(ctx), fill: true, pointRadius: 3, pointBackgroundColor: function (ctx) { let v = ctx.raw; return v >= 7 ? '#ff4c4c' : '#e67e22'; } }] },
                options: {
                    responsive: true,
                    plugins: { legend: { labels: { color: '#fff' } }, tooltip: { enabled: true } },
                    scales: {
                        x: { ticks: { color: '#bbb' }, grid: { color: '#333' } },
                        y: { min: 0, max: 10, ticks: { color: '#bbb' }, grid: { color: '#333' } }
                    }
                }
            });
            updateRiskChart();
        }

        function getGradient(ctx) {
            const gradient = ctx.createLinearGradient(0, 0, 0, 120);
            gradient.addColorStop(0, 'rgba(230,126,34,0.5)');
            gradient.addColorStop(1, 'rgba(230,126,34,0.05)');
            return gradient;
        }

        function updateRiskChart() {
            if (streamEnded || window.keepResultsVisible || processingComplete) return;
            fetch('/api/risk_trend').then(res => res.json()).then(trend => {
                if (!riskChart) return;
               
                const limitedTrend = trend.slice(-100);
                riskChart.data.labels = limitedTrend.map(t => t.frame_id);
                riskChart.data.datasets[0].data = limitedTrend.map(t => t.risk_score);
                
                if (streamEnded || window.keepResultsVisible || window.summaryLocked || processingComplete) {
                    riskChart.update({ animation: false });
                } else {
                    riskChart.update();
                }
                if (limitedTrend.length > 0 && videoDuration > 0) {
                    videoCurrent = limitedTrend[limitedTrend.length - 1].frame_id;
                    const percent = Math.min(100, ((videoCurrent + 1) / videoDuration) * 100);
                    document.getElementById('videoProgress').style.width = percent + '%';
                    document.getElementById('videoProgressLabel').textContent = `Frame ${videoCurrent + 1} / ${videoDuration} (${Math.round(percent)}%)`;
                }
                //only continue polling if stream is still active
                if (!streamEnded && !window.keepResultsVisible && !processingComplete) {
                    setTimeout(updateRiskChart, 1000);
                }
            });
        }

        function getVideoDuration(file) {
            const url = URL.createObjectURL(file);
            const vid = document.createElement('video');
            vid.preload = 'metadata';
            vid.onloadedmetadata = function () {
                window.URL.revokeObjectURL(url);
                videoDuration = Math.floor(vid.duration * 30);
                //dynamic throttling based on video length
                if (videoDuration < 200) frameRenderThrottle = 1;
                else if (videoDuration < 500) frameRenderThrottle = 3;
                else if (videoDuration < 1000) frameRenderThrottle = 7;
                else frameRenderThrottle = 10; //more aggressive for very large videos
                if (lowResourceMode) frameRenderThrottle = Math.max(frameRenderThrottle, 10);
            };
            vid.src = url;
        }

        //optional low resource mode toggle
        const container = document.querySelector('.container');
        const lowResToggle = document.createElement('div');
        lowResToggle.innerHTML = `<label style="font-size:0.95em;"><input type="checkbox" id="lowResModeToggle"> Low Resource Mode</label>`;
        container.insertBefore(lowResToggle, container.firstChild);
        document.getElementById('lowResModeToggle').addEventListener('change', function (e) {
            lowResourceMode = e.target.checked;
            if (videoDuration > 0) {
                if (lowResourceMode) frameRenderThrottle = Math.max(frameRenderThrottle, 10);
                else {
                    if (videoDuration < 200) frameRenderThrottle = 1;
                    else if (videoDuration < 500) frameRenderThrottle = 3;
                    else if (videoDuration < 1000) frameRenderThrottle = 7;
                    else frameRenderThrottle = 10;
                }
            }
        });

        async function startVideoStream() {
            console.log('startVideoStream called');
            try {
                if (streamController) streamController.abort();
                streamController = new AbortController();

                
                loadingSpinner.style.display = '';
                uploadResult.textContent = 'Processing video...';

                const response = await fetch('/stream', { signal: streamController.signal });
                const reader = response.body.getReader();
                let buffer = new Uint8Array();
                let boundary = new TextDecoder().decode(await reader.read().then(({ value }) => value)).match(/boundary=(.*)/)?.[1] || 'frame';
                boundary = '--' + boundary;
                let ended = false;
                let frameCount = 0;

                
                loadingSpinner.style.display = 'none';
                uploadResult.textContent = 'Streaming video...';

                while (!ended) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    buffer = concatUint8Arrays(buffer, value);
                    while (true) {
                        const idx = findBoundary(buffer, boundary);
                        if (idx === -1) break;

                        const part = buffer.slice(0, idx);
                        buffer = buffer.slice(idx + boundary.length);
                        if (part.length === 0) continue;

                        //header parsing
                        const headerBodySep = (() => {
                            for (let i = 0; i < part.length - 3; i++) {
                                if (part[i] === 13 && part[i + 1] === 10 && part[i + 2] === 13 && part[i + 3] === 10) {
                                    return i + 4;
                                }
                            }
                            return -1;
                        })();
                        let headers = '';
                        let bodyStart = 0;
                        if (headerBodySep !== -1) {
                            headers = new TextDecoder().decode(part.slice(0, headerBodySep)).toLowerCase();
                            bodyStart = headerBodySep;
                        } else {
                            headers = '';
                            bodyStart = 0;
                        }

                        if (headers.includes('x-stream-end: true')) {
                            console.log('x-stream-end detected, calling updateAllResults and onStreamEnd');
                            try {
                                const jsonStart = part.indexOf('{', bodyStart);
                                if (jsonStart > -1) {
                                    const jsonStr = new TextDecoder().decode(part.slice(jsonStart));
                                    const endData = JSON.parse(jsonStr);

                                    
                                    updateAllResults(endData.summary, endData.risk_trend);
                                    videoDuration = endData.total_frames;
                                }
                            } catch (e) {
                                console.error('Error parsing stream end data:', e);
                            }

                            processingComplete = true;
                            onStreamEnd(frameCount);
                            ended = true;
                            break;
                        }

                        const jpegStart = part.indexOf(0xff);
                        if (jpegStart === -1) continue;

                        const jpeg = part.slice(jpegStart);
                        frameCount++;

                        if (frameCount % frameRenderThrottle !== 0 && frameCount !== videoDuration) continue;

                        const blob = new Blob([jpeg], { type: 'image/jpeg' });
                        const img = new Image();
                        img.onload = function () {
                            requestAnimationFrame(() => {
                                ctx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
                                let scale = Math.min(videoCanvas.width / img.width, videoCanvas.height / img.height);
                                let w = img.width * scale;
                                let h = img.height * scale;
                                ctx.drawImage(img, 0, 0, w, h);
                            });
                        };
                        img.src = URL.createObjectURL(blob);
                    }
                }
                
                console.log('After stream ends, buffer length:', buffer.length, 'buffer:', buffer);
                //final buffer flush after stream ends
                if (!ended && buffer.length > 0) {
                    const idx = findBoundary(buffer, boundary);
                    console.log('Final buffer flush, idx:', idx);
                    let part;
                    if (idx !== -1) {
                        part = buffer.slice(0, idx);
                    } else {
                        //if no boundary...treat the whole buffer as the last part
                        part = buffer;
                        console.log('No boundary found, treating entire buffer as last part');
                    }
                    if (part.length > 0) {
                        //header parsing
                        const headerBodySep = (() => {
                            for (let i = 0; i < part.length - 3; i++) {
                                if (part[i] === 13 && part[i + 1] === 10 && part[i + 2] === 13 && part[i + 3] === 10) {
                                    return i + 4;
                                }
                            }
                            return -1;
                        })();
                        let headers = '';
                        let bodyStart = 0;
                        if (headerBodySep !== -1) {
                            headers = new TextDecoder().decode(part.slice(0, headerBodySep)).toLowerCase();
                            bodyStart = headerBodySep;
                        } else {
                            headers = '';
                            bodyStart = 0;
                        }
                        console.log('Final buffer flush, headers:', headers);
                        if (headers.includes('x-stream-end: true')) {
                            console.log('x-stream-end detected in final buffer flush, calling updateAllResults and onStreamEnd');
                            try {
                                const jsonStart = part.indexOf('{', bodyStart);
                                if (jsonStart > -1) {
                                    const jsonStr = new TextDecoder().decode(part.slice(jsonStart));
                                    try {
                                        console.log('Raw JSON string (first 200 chars):', jsonStr.slice(0, 200));
                                    } catch (e) {
                                        console.error('Error logging JSON string:', e);
                                    }
                                    let endData;
                                    try {
                                        endData = JSON.parse(jsonStr);
                                    } catch (e) {
                                        console.error('Error parsing JSON:', e, jsonStr);
                                        endData = null;
                                    }
                                    if (endData) {
                                        console.log('endData before updateAllResults:', endData);
                                        try {
                                            updateAllResults(endData.summary, endData.risk_trend);
                                        } catch (err) {
                                            console.error('Error in updateAllResults:', err, endData);
                                        }
                                        videoDuration = endData.total_frames;
                                    }
                                }
                            } catch (e) {
                                console.error('Error parsing stream end data (final flush):', e);
                            }
                            processingComplete = true;
                            onStreamEnd(frameCount);
                        }
                    }
                }
            } catch (err) {
                console.error('Stream error:', err);
                loadingSpinner.style.display = 'none';

                if (streamEnded) {
                   
                    uploadResult.innerHTML = '<span class="text-warning">Processing stopped. Finalizing results...</span>';
                    fetchFinalResults();
                } else {
                    
                    uploadResult.innerHTML = '<span class="text-danger">Video processing error. Please try again.</span>';
                    document.getElementById('resultsSection').style.display = 'block';
                    forceResultsVisible();
                }
            }
        }

        function updateAllResults(summary, riskTrend) {
            console.log('updateAllResults called with summary:', summary, 'riskTrend:', riskTrend);
            if (pollSessionTimeout) clearTimeout(pollSessionTimeout);
            pollSessionTimeout = null;
            setResultsSectionVisible(true);
            forceResultsVisible();
            window.summaryLocked = false;

            //store the final summary for fallback use
            if (summary) {
                window.finalSessionSummary = summary;
            }

            setTimeout(() => {
                console.log('setTimeout in updateAllResults fired, calling showSessionSummary');
                if (summary) {
                    showSessionSummary(summary);
                } else {
                    console.log('updateAllResults: No summary provided, fetching from API');
                    fetch('/api/session_summary').then(res => res.json()).then(summaryData => {
                        showSessionSummary(summaryData);
                    });
                }

                //update risk chart after a short delay to ensure DOM is ready
                setTimeout(() => {
                    if (riskChart && riskTrend) {
                        riskChart.data.labels = riskTrend.map(t => t.frame_id);
                        riskChart.data.datasets[0].data = riskTrend.map(t => t.risk_score);
                        riskChart.update({ animation: false });
                    }
                }, 100);
            }, 100); //increased delay to ensure DOM is ready

            setTimeout(() => {
                window.summaryLocked = true;
            }, 500); 
        }

        function concatUint8Arrays(a, b) {
            let c = new Uint8Array(a.length + b.length);
            c.set(a, 0); c.set(b, a.length); return c;
        }

        function onStreamEnd(finalFrameCount) {
            console.log('onStreamEnd called. Setting pollingActive to false.');
            if (pollSessionTimeout) clearTimeout(pollSessionTimeout);
            pollSessionTimeout = null;
            streamEnded = true;
            window.keepResultsVisible = true;
            processingComplete = true;
            window.pollingActive = false;
            
            document.getElementById('videoProgressLabel').textContent = `Frame ${videoDuration} / ${videoDuration} (100%)`;
            document.getElementById('videoProgress').style.width = '100%';
            uploadResult.innerHTML = '<span class="text-success">Processing complete!</span> <button class="btn btn-sm btn-primary ms-2" onclick="location.reload()">Upload New</button>';

            setResultsSectionVisible(true);
            forceResultsVisible();

            //ensure final results are displayed when stream ends naturally
            setTimeout(() => {
                if (window.finalSessionSummary) {
                    console.log('onStreamEnd: displaying final session summary');
                    showSessionSummary(window.finalSessionSummary);
                } else {
                    console.log('onStreamEnd: fetching final results');
                    fetchFinalResults();
                }
            }, 300);

            //fallback:if charts are not created after 1 second, try again
            setTimeout(() => {
                const speciesCanvas = document.getElementById('speciesChartCanvas');
                const riskCanvas = document.getElementById('riskBarChartCanvas');
                if ((!speciesCanvas || !window.speciesChart) || (!riskCanvas || !window.riskBarChart)) {
                    console.log('onStreamEnd: Charts not created, retrying...');
                    if (window.finalSessionSummary) {
                        showSessionSummary(window.finalSessionSummary);
                    }
                }
            }, 1000);
        }

        
        function preventAutoHide() {
            const resultsSection = document.getElementById('resultsSection');
            if ((resultsSection.style.display === 'none' && window.keepResultsVisible) || processingComplete) {
                resultsSection.style.display = 'block';
            }
        }

        
        document.getElementById('stopStreamBtn').addEventListener('click', function () {
            if (streamController) {
                streamEnded = true;
                window.keepResultsVisible = true;
                streamController.abort();
            }
            window.pollingActive = false;
            
            const stopBtn = document.getElementById('stopStreamBtn');
            stopBtn.disabled = true;
            stopBtn.style.opacity = 0.6;
            stopBtn.style.pointerEvents = 'none';

            uploadResult.innerHTML = '<span class="text-warning">Processing stopped. Finalizing results...</span>';

            fetchFinalResults();
        });

        function fetchFinalResults() {
            setResultsSectionVisible(true); 
            Promise.all([
                fetch('/api/session_summary').then(res => res.json()),
                fetch('/api/risk_trend').then(res => res.json())
            ]).then(([summary, trend]) => {
                updateAllResults(summary, trend);
                uploadResult.innerHTML = '<span class="text-success">Results ready!</span> <button class="btn btn-sm btn-primary ms-2" onclick="location.reload()">Upload New</button>';
            }).catch(error => {
                console.error('Error fetching final results:', error);
                uploadResult.innerHTML = '<span class="text-warning">Results may be incomplete.</span> <button class="btn btn-sm btn-primary ms-2" onclick="location.reload()">Upload New</button>';
                setResultsSectionVisible(true);
            });
        }

        //restart/refresh button logic
        document.getElementById('restartBtn').addEventListener('click', function () {
            
            if (streamController) streamController.abort();
            if (pollSessionTimeout) clearTimeout(pollSessionTimeout);
            streamEnded = false;
            processingComplete = false;
            imageResult.style.display = 'none';
            videoResult.style.display = 'none';
            uploadResult.textContent = '';
            loadingSpinner.style.display = 'none';
            sessionSummaryDiv.innerHTML = '';
            detectionList.innerHTML = '';
            riskSummary.innerHTML = '';
            document.getElementById('resultsSection').style.display = 'none';
            document.getElementById('stopStreamBtn').style.display = 'inline-block';
            fileUpload.value = '';
            if (riskChart) { riskChart.destroy(); riskChart = null; }
            if (speciesChart) { speciesChart.destroy(); speciesChart = null; }
            if (riskBarChart) { riskBarChart.destroy(); riskBarChart = null; }
            ctx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
            videoCurrent = 0;
            videoDuration = 0;
            document.getElementById('videoProgress').style.width = '0%';
            document.getElementById('videoProgressLabel').textContent = '';
            
            setResultsSectionVisible(false);
            window.keepResultsVisible = false; //reset flag on restart
            window.summaryLocked = false;
            window.pollingActive = false;
            
            const stopBtn = document.getElementById('stopStreamBtn');
            stopBtn.disabled = true;
            stopBtn.style.opacity = 0.6;
            stopBtn.style.pointerEvents = 'none';
        });
    </script>
</body>

</html>